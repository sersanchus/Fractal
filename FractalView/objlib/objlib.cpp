#include <math.h>
#include <stdlib.h>
#include <string.h>
//#include <assert.h>
#include "ObjLib.h"

#include <GL/glut.h>

/*
// glmWriteMTL: write a wavefront material library file
// model   - properly initialized OLModel structure
// modelpath  - pathname of the model being written
// mtllibname - name of the material library to be written
static GLvoid glmWriteMTL(OLModel* model, char* modelpath, char* mtllibname)
{
    FILE* file;
    char* dir;
    char* filename;
    GLMmaterial* material;
    GLuint i;
    
    dir = glmDirName(modelpath);
    filename = (char*)malloc(sizeof(char) * (strlen(dir)+strlen(mtllibname)));
    strcpy(filename, dir);
    strcat(filename, mtllibname);
    free(dir);
    
    // open the file 
    file = fopen(filename, "w");
    if (!file) {
        fprintf(stderr, "glmWriteMTL() failed: can't open file \"%s\".\n",
            filename);
        exit(1);
    }
    free(filename);
    
    // spit out a header 
    fprintf(file, "#  \n");
    fprintf(file, "#  Wavefront MTL generated by GLM library\n");
    fprintf(file, "#  \n");
    fprintf(file, "#  GLM library\n");
    fprintf(file, "#  Nate Robins\n");
    fprintf(file, "#  ndr@pobox.com\n");
    fprintf(file, "#  http://www.pobox.com/~ndr\n");
    fprintf(file, "#  \n\n");
    
    for (i = 0; i < model->nummaterials; i++) {
        material = &model->materials[i];
        fprintf(file, "newmtl %s\n", material->name);
        fprintf(file, "Ka %f %f %f\n", 
            material->ambient[0], material->ambient[1], material->ambient[2]);
        fprintf(file, "Kd %f %f %f\n", 
            material->diffuse[0], material->diffuse[1], material->diffuse[2]);
        fprintf(file, "Ks %f %f %f\n", 
            material->specular[0],material->specular[1],material->specular[2]);
        fprintf(file, "Ns %f\n", material->shininess / 128.0 * 1000.0);
        fprintf(file, "\n");
    }
}


// glmUnitize: "unitize" a model by translating it to the origin and
// scaling it to fit in a unit cube around the origin.   Returns the
// scalefactor used.
// model - properly initialized OLModel structure 
GLfloat glmUnitize(OLModel* model)
{
    GLuint  i;
    GLfloat maxx, minx, maxy, miny, maxz, minz;
    GLfloat cx, cy, cz, w, h, d;
    GLfloat scale;
    
    assert(model);
    assert(model->vertices);
    
    // get the max/mins 
    maxx = minx = model->vertices[3 + 0];
    maxy = miny = model->vertices[3 + 1];
    maxz = minz = model->vertices[3 + 2];
    for (i = 1; i <= model->numvertices; i++) {
        if (maxx < model->vertices[3 * i + 0])
            maxx = model->vertices[3 * i + 0];
        if (minx > model->vertices[3 * i + 0])
            minx = model->vertices[3 * i + 0];
        
        if (maxy < model->vertices[3 * i + 1])
            maxy = model->vertices[3 * i + 1];
        if (miny > model->vertices[3 * i + 1])
            miny = model->vertices[3 * i + 1];
        
        if (maxz < model->vertices[3 * i + 2])
            maxz = model->vertices[3 * i + 2];
        if (minz > model->vertices[3 * i + 2])
            minz = model->vertices[3 * i + 2];
    }
    
    // calculate model width, height, and depth 
    w = glmAbs(maxx) + glmAbs(minx);
    h = glmAbs(maxy) + glmAbs(miny);
    d = glmAbs(maxz) + glmAbs(minz);
    
    // calculate center of the model 
    cx = (maxx + minx) / 2.0;
    cy = (maxy + miny) / 2.0;
    cz = (maxz + minz) / 2.0;
    
    // calculate unitizing scale factor 
    scale = 2.0 / glmMax(glmMax(w, h), d);
    
    // translate around center then scale 
    for (i = 1; i <= model->numvertices; i++) {
        model->vertices[3 * i + 0] -= cx;
        model->vertices[3 * i + 1] -= cy;
        model->vertices[3 * i + 2] -= cz;
        model->vertices[3 * i + 0] *= scale;
        model->vertices[3 * i + 1] *= scale;
        model->vertices[3 * i + 2] *= scale;
    }
    
    return scale;
}

// glmDimensions: Calculates the dimensions (width, height, depth) of
// a model.
// model   - initialized OLModel structure
// dimensions - array of 3 GLfloats (GLfloat dimensions[3])
GLvoid glmDimensions(OLModel* model, GLfloat* dimensions)
{
    GLuint i;
    GLfloat maxx, minx, maxy, miny, maxz, minz;
    
    assert(model);
    assert(model->vertices);
    assert(dimensions);
    
    // get the max/mins 
    maxx = minx = model->vertices[3 + 0];
    maxy = miny = model->vertices[3 + 1];
    maxz = minz = model->vertices[3 + 2];
    for (i = 1; i <= model->numvertices; i++) {
        if (maxx < model->vertices[3 * i + 0])
            maxx = model->vertices[3 * i + 0];
        if (minx > model->vertices[3 * i + 0])
            minx = model->vertices[3 * i + 0];
        
        if (maxy < model->vertices[3 * i + 1])
            maxy = model->vertices[3 * i + 1];
        if (miny > model->vertices[3 * i + 1])
            miny = model->vertices[3 * i + 1];
        
        if (maxz < model->vertices[3 * i + 2])
            maxz = model->vertices[3 * i + 2];
        if (minz > model->vertices[3 * i + 2])
            minz = model->vertices[3 * i + 2];
    }
    
    // calculate model width, height, and depth 
    dimensions[0] = glmAbs(maxx) + glmAbs(minx);
    dimensions[1] = glmAbs(maxy) + glmAbs(miny);
    dimensions[2] = glmAbs(maxz) + glmAbs(minz);
}

// glmScale: Scales a model by a given amount.
// model - properly initialized OLModel structure
// scale - scalefactor (0.5 = half as large, 2.0 = twice as large)
GLvoid glmScale(OLModel* model, GLfloat scale)
{
    GLuint i;
    
    for (i = 1; i <= model->numvertices; i++) {
        model->vertices[3 * i + 0] *= scale;
        model->vertices[3 * i + 1] *= scale;
        model->vertices[3 * i + 2] *= scale;
    }
}

// glmLinearTexture: Generates texture coordinates according to a
// linear projection of the texture map.  It generates these by
// linearly mapping the vertices onto a square.
// model - pointer to initialized OLModel structure
GLvoid glmLinearTexture(OLModel* model)
{
    OLGroup *group;
    GLfloat dimensions[3];
    GLfloat x, y, scalefactor;
    GLuint i;
    
    assert(model);
    
    if (model->texcoords)
        free(model->texcoords);
    model->numtexcoords = model->numvertices;
    model->texcoords=(GLfloat*)malloc(sizeof(GLfloat)*2*(model->numtexcoords+1));
    
    glmDimensions(model, dimensions);
    scalefactor = 2.0 / 
        glmAbs(glmMax(glmMax(dimensions[0], dimensions[1]), dimensions[2]));
    
    // do the calculations 
    for(i = 1; i <= model->numvertices; i++) {
        x = model->vertices[3 * i + 0] * scalefactor;
        y = model->vertices[3 * i + 2] * scalefactor;
        model->texcoords[2 * i + 0] = (x + 1.0) / 2.0;
        model->texcoords[2 * i + 1] = (y + 1.0) / 2.0;
    }
    
    // go through and put texture coordinate indices in all the triangles 
    group = model->groups;
    while(group) {
        for(i = 0; i < group->numtriangles; i++) {
            T(group->triangles[i]).tindices[0] = T(group->triangles[i]).vindices[0];
            T(group->triangles[i]).tindices[1] = T(group->triangles[i]).vindices[1];
            T(group->triangles[i]).tindices[2] = T(group->triangles[i]).vindices[2];
        }    
        group = group->next;
    }
}

// glmSpheremapTexture: Generates texture coordinates according to a
// spherical projection of the texture map.  Sometimes referred to as
// spheremap, or reflection map texture coordinates.  It generates
// these by using the normal to calculate where that vertex would map
// onto a sphere.  Since it is impossible to map something flat
// perfectly onto something spherical, there is distortion at the
// poles.  This particular implementation causes the poles along the X
// axis to be distorted.
// model - pointer to initialized OLModel structure
GLvoid glmSpheremapTexture(OLModel* model)
{
    OLGroup* group;
    GLfloat theta, phi, rho, x, y, z, r;
    GLuint i;
    
    assert(model);
    assert(model->normals);
    
    if (model->texcoords)
        free(model->texcoords);
    model->numtexcoords = model->numnormals;
    model->texcoords=(GLfloat*)malloc(sizeof(GLfloat)*2*(model->numtexcoords+1));
    
    for (i = 1; i <= model->numnormals; i++) {
        z = model->normals[3 * i + 0];  // re-arrange for pole distortion 
        y = model->normals[3 * i + 1];
        x = model->normals[3 * i + 2];
        r = sqrt((x * x) + (y * y));
        rho = sqrt((r * r) + (z * z));
        
        if(r == 0.0) {
            theta = 0.0;
            phi = 0.0;
        } else {
            if(z == 0.0)
                phi = 3.14159265 / 2.0;
            else
                phi = acos(z / rho);
            
            if(y == 0.0)
                theta = 3.141592365 / 2.0;
            else
                theta = asin(y / r) + (3.14159265 / 2.0);
        }
        
        model->texcoords[2 * i + 0] = theta / 3.14159265;
        model->texcoords[2 * i + 1] = phi / 3.14159265;
    }
    
    // go through and put texcoord indices in all the triangles 
    group = model->groups;
    while(group) {
        for (i = 0; i < group->numtriangles; i++) {
            T(group->triangles[i]).tindices[0] = T(group->triangles[i]).nindices[0];
            T(group->triangles[i]).tindices[1] = T(group->triangles[i]).nindices[1];
            T(group->triangles[i]).tindices[2] = T(group->triangles[i]).nindices[2];
        }
        group = group->next;
    }
}

// glmWriteOBJ: Writes a model description in Wavefront .OBJ format to
// a file.
// model - initialized OLModel structure
// filename - name of the file to write the Wavefront .OBJ format data to
// mode  - a bitwise or of values describing what is written to the file
//             GLM_NONE     -  render with only vertices
//             GLM_FLAT     -  render with facet normals
//             GLM_SMOOTH   -  render with vertex normals
//             GLM_TEXTURE  -  render with texture coords
//             GLM_COLOR    -  render with colors (color material)
//             GLM_MATERIAL -  render with materials
//             GLM_COLOR and GLM_MATERIAL should not both be specified.  
//             GLM_FLAT and GLM_SMOOTH should not both be specified.  
GLvoid glmWriteOBJ(OLModel* model, char* filename, GLuint mode)
{
    GLuint  i;
    FILE*   file;
    OLGroup* group;
    
    assert(model);
    
    // do a bit of warning 
    if (mode & GLM_FLAT && !model->facetnorms) {
        printf("glmWriteOBJ() warning: flat normal output requested "
            "with no facet normals defined.\n");
        mode &= ~GLM_FLAT;
    }
    if (mode & GLM_SMOOTH && !model->normals) {
        printf("glmWriteOBJ() warning: smooth normal output requested "
            "with no normals defined.\n");
        mode &= ~GLM_SMOOTH;
    }
    if (mode & GLM_TEXTURE && !model->texcoords) {
        printf("glmWriteOBJ() warning: texture coordinate output requested "
            "with no texture coordinates defined.\n");
        mode &= ~GLM_TEXTURE;
    }
    if (mode & GLM_FLAT && mode & GLM_SMOOTH) {
        printf("glmWriteOBJ() warning: flat normal output requested "
            "and smooth normal output requested (using smooth).\n");
        mode &= ~GLM_FLAT;
    }
    if (mode & GLM_COLOR && !model->materials) {
        printf("glmWriteOBJ() warning: color output requested "
            "with no colors (materials) defined.\n");
        mode &= ~GLM_COLOR;
    }
    if (mode & GLM_MATERIAL && !model->materials) {
        printf("glmWriteOBJ() warning: material output requested "
            "with no materials defined.\n");
        mode &= ~GLM_MATERIAL;
    }
    if (mode & GLM_COLOR && mode & GLM_MATERIAL) {
        printf("glmWriteOBJ() warning: color and material output requested "
            "outputting only materials.\n");
        mode &= ~GLM_COLOR;
    }
    
    
    // open the file 
    file = fopen(filename, "w");
    if (!file) {
        fprintf(stderr, "glmWriteOBJ() failed: can't open file \"%s\" to write.\n",
            filename);
        exit(1);
    }
    
    // spit out a header 
    fprintf(file, "#  \n");
    fprintf(file, "#  Wavefront OBJ generated by GLM library\n");
    fprintf(file, "#  \n");
    fprintf(file, "#  GLM library\n");
    fprintf(file, "#  Nate Robins\n");
    fprintf(file, "#  ndr@pobox.com\n");
    fprintf(file, "#  http://www.pobox.com/~ndr\n");
    fprintf(file, "#  \n");
    
    if (mode & GLM_MATERIAL && model->mtllibname) {
        fprintf(file, "\nmtllib %s\n\n", model->mtllibname);
        glmWriteMTL(model, filename, model->mtllibname);
    }
    
    // spit out the vertices 
    fprintf(file, "\n");
    fprintf(file, "# %d vertices\n", model->numvertices);
    for (i = 1; i <= model->numvertices; i++) {
        fprintf(file, "v %f %f %f\n", 
            model->vertices[3 * i + 0],
            model->vertices[3 * i + 1],
            model->vertices[3 * i + 2]);
    }
    
    // spit out the smooth/flat normals 
    if (mode & GLM_SMOOTH) {
        fprintf(file, "\n");
        fprintf(file, "# %d normals\n", model->numnormals);
        for (i = 1; i <= model->numnormals; i++) {
            fprintf(file, "vn %f %f %f\n", 
                model->normals[3 * i + 0],
                model->normals[3 * i + 1],
                model->normals[3 * i + 2]);
        }
    } else if (mode & GLM_FLAT) {
        fprintf(file, "\n");
        fprintf(file, "# %d normals\n", model->numfacetnorms);
        for (i = 1; i <= model->numnormals; i++) {
            fprintf(file, "vn %f %f %f\n", 
                model->facetnorms[3 * i + 0],
                model->facetnorms[3 * i + 1],
                model->facetnorms[3 * i + 2]);
        }
    }
    
    // spit out the texture coordinates 
    if (mode & GLM_TEXTURE) {
        fprintf(file, "\n");
        fprintf(file, "# %d texcoords\n", model->texcoords);
        for (i = 1; i <= model->numtexcoords; i++) {
            fprintf(file, "vt %f %f\n", 
                model->texcoords[2 * i + 0],
                model->texcoords[2 * i + 1]);
        }
    }
    
    fprintf(file, "\n");
    fprintf(file, "# %d groups\n", model->numgroups);
    fprintf(file, "# %d faces (triangles)\n", model->numtriangles);
    fprintf(file, "\n");
    
    group = model->groups;
    while(group) {
        fprintf(file, "g %s\n", group->name);
        if (mode & GLM_MATERIAL)
            fprintf(file, "usemtl %s\n", model->materials[group->material].name);
        for (i = 0; i < group->numtriangles; i++) {
            if (mode & GLM_SMOOTH && mode & GLM_TEXTURE) {
                fprintf(file, "f %d/%d/%d %d/%d/%d %d/%d/%d\n",
                    T(group->triangles[i]).vindices[0], 
                    T(group->triangles[i]).nindices[0], 
                    T(group->triangles[i]).tindices[0],
                    T(group->triangles[i]).vindices[1],
                    T(group->triangles[i]).nindices[1],
                    T(group->triangles[i]).tindices[1],
                    T(group->triangles[i]).vindices[2],
                    T(group->triangles[i]).nindices[2],
                    T(group->triangles[i]).tindices[2]);
            } else if (mode & GLM_FLAT && mode & GLM_TEXTURE) {
                fprintf(file, "f %d/%d %d/%d %d/%d\n",
                    T(group->triangles[i]).vindices[0],
                    T(group->triangles[i]).findex,
                    T(group->triangles[i]).vindices[1],
                    T(group->triangles[i]).findex,
                    T(group->triangles[i]).vindices[2],
                    T(group->triangles[i]).findex);
            } else if (mode & GLM_TEXTURE) {
                fprintf(file, "f %d/%d %d/%d %d/%d\n",
                    T(group->triangles[i]).vindices[0],
                    T(group->triangles[i]).tindices[0],
                    T(group->triangles[i]).vindices[1],
                    T(group->triangles[i]).tindices[1],
                    T(group->triangles[i]).vindices[2],
                    T(group->triangles[i]).tindices[2]);
            } else if (mode & GLM_SMOOTH) {
                fprintf(file, "f %d//%d %d//%d %d//%d\n",
                    T(group->triangles[i]).vindices[0],
                    T(group->triangles[i]).nindices[0],
                    T(group->triangles[i]).vindices[1],
                    T(group->triangles[i]).nindices[1],
                    T(group->triangles[i]).vindices[2], 
                    T(group->triangles[i]).nindices[2]);
            } else if (mode & GLM_FLAT) {
                fprintf(file, "f %d//%d %d//%d %d//%d\n",
                    T(group->triangles[i]).vindices[0], 
                    T(group->triangles[i]).findex,
                    T(group->triangles[i]).vindices[1],
                    T(group->triangles[i]).findex,
                    T(group->triangles[i]).vindices[2],
                    T(group->triangles[i]).findex);
            } else {
                fprintf(file, "f %d %d %d\n",
                    T(group->triangles[i]).vindices[0],
                    T(group->triangles[i]).vindices[1],
                    T(group->triangles[i]).vindices[2]);
            }
        }
        fprintf(file, "\n");
        group = group->next;
    }
    
    fclose(file);
}

// glmList: Generates and returns a display list for the model using
// the mode specified.
// model - initialized OLModel structure
// mode  - a bitwise OR of values describing what is to be rendered.
//             GLM_NONE     -  render with only vertices
//             GLM_FLAT     -  render with facet normals
//             GLM_SMOOTH   -  render with vertex normals
//             GLM_TEXTURE  -  render with texture coords
//             GLM_COLOR    -  render with colors (color material)
//             GLM_MATERIAL -  render with materials
//             GLM_COLOR and GLM_MATERIAL should not both be specified.  
// GLM_FLAT and GLM_SMOOTH should not both be specified.  
GLuint glmList(OLModel* model, GLuint mode)
{
    GLuint list;
    
    list = glGenLists(1);
    glNewList(list, GL_COMPILE);
    glmDraw(model, mode);
    glEndList();
    
    return list;
}*/

// OLDot: compute the dot product of two vectors
// u - array of 3 GLfloats (GLfloat u[3])
// v - array of 3 GLfloats (GLfloat v[3])
static float OLDot(float* u, float* v)
{
    return u[0]*v[0] + u[1]*v[1] + u[2]*v[2];
}

// OLCross: compute the cross product of two vectors
// u - array of 3 GLfloats (GLfloat u[3])
// v - array of 3 GLfloats (GLfloat v[3])
// n - array of 3 GLfloats (GLfloat n[3]) to return the cross product in
static void OLCross(float* u, float* v, float* n)
{
    n[0] = u[1]*v[2] - u[2]*v[1];
    n[1] = u[2]*v[0] - u[0]*v[2];
    n[2] = u[0]*v[1] - u[1]*v[0];
}

// OLNormalize: normalize a vector
// v - array of 3 GLfloats (GLfloat v[3]) to be normalized
static void OLNormalize(float* v)
{
    float l = 1.0f/sqrtf(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
    v[0] *= l;
    v[1] *= l;
    v[2] *= l;
}

// OLEqual: compares two vectors and returns true if they are
// equal (within a certain threshold) or false if not. An epsilon
// that works fairly well is 0.000001.
// u - array of 3 GLfloats (GLfloat u[3])
// v - array of 3 GLfloats (GLfloat v[3]) 
static bool OLEqual(float* u, float* v, float epsilon)
{
    return (fabs(u[0] - v[0]) < epsilon &&  fabs(u[1] - v[1]) < epsilon && fabs(u[2] - v[2]) < epsilon);
}



// OLWeldVectors: eliminate (weld) vectors that are within an
// epsilon of each other.
// vectors     - array of GLfloat[3]'s to be welded
// numvectors - number of GLfloat[3]'s in vectors
// epsilon     - maximum difference between vectors 
static float* OLWeldVectors(float* vectors, unsigned int* numvectors, float epsilon)
{
    float* copies;
    unsigned int   copied;
    unsigned int   i, j;
    
    copies = (float*)malloc(sizeof(float) * 3 * (*numvectors));
    memcpy(copies, vectors, (sizeof(float) * 3 * (*numvectors)));
    
    copied = 0;
    for (i = 0; i < *numvectors; i++) 
	{
        for (j = 0; j < copied; j++) 
		{
            if (OLEqual(&vectors[3 * i], &copies[3 * j], epsilon)) 
			{
                goto duplicate;
            }
        }
        
        // must not be any duplicates -- add to the copies array 
        copies[3 * copied + 0] = vectors[3 * i + 0];
        copies[3 * copied + 1] = vectors[3 * i + 1];
        copies[3 * copied + 2] = vectors[3 * i + 2];
        j = copied;             // pass this along for below 
        copied++;
        
duplicate:
		// set the first component of this vector to point at the correct index into the new copies array 
        vectors[3 * i + 0] = (float)j;
    }
    
    *numvectors = copied;
    return copies;
}

// glmDirName: return the directory given a path
// path - filesystem path
// NOTE: the return value should be free'd.
static char* DirName(char* path)
{
    char* dir;
    char* s;
    
    dir = _strdup(path);
    
    s = strrchr(dir, '/');
    if (s)
        s[1] = '\0';
    else
        dir[0] = '\0';
    
    return dir;
}

// glmFindGroup: Find a material in the model 
unsigned int OLModel::FindMaterial(char* name)
{
    unsigned int i;
    
    // XXX doing a linear search on a string key'd list is pretty lame, but it works and is fast enough for now. 
    for (i = 0; i < nummaterials; i++) 
	{
        if (!strcmp(materials[i].name, name))
            goto found;
    }
    
    // didn't find the name, so print a warning and return the default material (0). 
    printf("FindMaterial():  can't find material \"%s\".\n", name);
    i = 0;
    
found:
    return i;
}

// FindGroup: Find a group in the model 
OLGroup* OLModel::FindGroup(char* name)
{
    OLGroup* group=groups;
    while(group) 
	{
        if (!strcmp(name, group->name))
            break;
        group = group->next;
    }    
    return group;
}

// AddGroup: Add a group to the model 
OLGroup* OLModel::AddGroup(char* name)
{
    OLGroup* group=FindGroup(name);
    if (!group) 
	{
        group = (OLGroup*)malloc(sizeof(OLGroup));
        group->name = _strdup(name);
        group->material = 0;
        group->numtriangles = 0;
        group->triangles = NULL;
        group->next = groups;
        groups = group;
        numgroups++;
    }    
    return group;
}

// ReadMTL: read a wavefront material library file
// name  - name of the material library
bool OLModel::ReadMTL(char* name)
{
    FILE* file;
    char* dir;
    char* filename;
    char    buf[128];
    unsigned int nummaterials, i;
    
    dir = DirName(pathname);
    filename = (char*)malloc(sizeof(char) * (strlen(dir) + strlen(name) + 1));
    strcpy(filename, dir);
    strcat(filename, name);
    free(dir);
    
    file = fopen(filename, "r");
    if (!file) {
        fprintf(stderr, "ReadMTL() failed: can't open material file \"%s\".\n",
            filename);
		free(filename);
        return false;
    }
    free(filename);
    
    // count the number of materials in the file 
    nummaterials = 1;
    while(fscanf(file, "%s", buf) != EOF) {
        switch(buf[0]) {
        case '#':               // comment 
            // eat up rest of line 
            fgets(buf, sizeof(buf), file);
            break;
        case 'n':               // newmtl 
            fgets(buf, sizeof(buf), file);
            nummaterials++;
            sscanf(buf, "%s %s", buf, buf);
            break;
        default:
            // eat up rest of line 
            fgets(buf, sizeof(buf), file);
            break;
        }
    }
    
    rewind(file);
    
    materials = (OLMaterial*)malloc(sizeof(OLMaterial) * nummaterials);
    nummaterials = nummaterials;
    
    // set the default material 
    for (i = 0; i < nummaterials; i++) {
        materials[i].name = NULL;
        materials[i].shininess = 65.0f;
        materials[i].diffuse[0] = 0.8f;
        materials[i].diffuse[1] = 0.8f;
        materials[i].diffuse[2] = 0.8f;
        materials[i].diffuse[3] = 1.0f;
        materials[i].ambient[0] = 0.2f;
        materials[i].ambient[1] = 0.2f;
        materials[i].ambient[2] = 0.2f;
        materials[i].ambient[3] = 1.0f;
        materials[i].specular[0] = 0.0f;
        materials[i].specular[1] = 0.0f;
        materials[i].specular[2] = 0.0f;
        materials[i].specular[3] = 1.0f;
    }
    materials[0].name = _strdup("default");
    
    // now, read in the data 
    nummaterials = 0;
    while(fscanf(file, "%s", buf) != EOF) {
        switch(buf[0]) {
        case '#':               // comment 
            // eat up rest of line 
            fgets(buf, sizeof(buf), file);
            break;
        case 'n':               // newmtl 
            fgets(buf, sizeof(buf), file);
            sscanf(buf, "%s %s", buf, buf);
            nummaterials++;
            materials[nummaterials].name = _strdup(buf);
            break;
        case 'N':
            fscanf(file, "%f", &materials[nummaterials].shininess);
            // wavefront shininess is from [0, 1000], so scale for OpenGL 
            materials[nummaterials].shininess /= 1000.0;
            materials[nummaterials].shininess *= 128.0;
            break;
        case 'K':
            switch(buf[1]) {
            case 'd':
                fscanf(file, "%f %f %f",
                    &materials[nummaterials].diffuse[0],
                    &materials[nummaterials].diffuse[1],
                    &materials[nummaterials].diffuse[2]);
                break;
            case 's':
                fscanf(file, "%f %f %f",
                    &materials[nummaterials].specular[0],
                    &materials[nummaterials].specular[1],
                    &materials[nummaterials].specular[2]);
                break;
            case 'a':
                fscanf(file, "%f %f %f",
                    &materials[nummaterials].ambient[0],
                    &materials[nummaterials].ambient[1],
                    &materials[nummaterials].ambient[2]);
                break;
            default:
                // eat up rest of line 
                fgets(buf, sizeof(buf), file);
                break;
            }
            break;
            default:
                // eat up rest of line 
                fgets(buf, sizeof(buf), file);
                break;
        }
    }

	return true;
}

// glmFirstPass: first pass at a Wavefront OBJ file that gets all the
// statistics of the model (such as #vertices, #normals, etc)
// file  - (fopen'd) file descriptor 
void OLModel::FirstPass(FILE* file) 
{
	OLGroup* group;					// current group 
	unsigned v, n, t;
	char buf[128];

	// make a default group 
	group=AddGroup("default");

	numvertices = numnormals = numtexcoords = numtriangles = 0;
	while(fscanf(file, "%s", buf) != EOF) 
	{
		switch(buf[0]) 
		{
		case '#':               // comment 
			// eat up rest of line 
			fgets(buf, sizeof(buf), file);
			break;
		case 'v':               // v, vn, vt 
			switch(buf[1]) 
			{
			case '\0':          // vertex 
				// eat up rest of line 
				fgets(buf, sizeof(buf), file);
				numvertices++;
				break;
			case 'n':           // normal 
				// eat up rest of line 
				fgets(buf, sizeof(buf), file);
				numnormals++;
				break;
			case 't':           // texcoord 
				// eat up rest of line 
				fgets(buf, sizeof(buf), file);
				numtexcoords++;
				break;
			default:
				printf("FirstPass(): Unknown token \"%s\".\n", buf);
				break;
			}
			break;
		case 'm':
			fgets(buf, sizeof(buf), file);
			sscanf(buf, "%s %s", buf, buf);
			mtllibname = _strdup(buf);
			ReadMTL(buf);
			break;
		case 'u':
			// eat up rest of line 
			fgets(buf, sizeof(buf), file);
			break;
		case 'g':               // group 
			// eat up rest of line 
			fgets(buf, sizeof(buf), file);
#if SINGLE_STRING_GROUP_NAMES
			sscanf(buf, "%s", buf);
#else
			buf[strlen(buf)-1] = '\0';  // nuke '\n' 
#endif
			group = AddGroup(buf);
			break;
		case 'f':               // face 
			v = n = t = 0;
			fscanf(file, "%s", buf);
			// can be one of %d, %d//%d, %d/%d, %d/%d/%d %d//%d 
			if (strstr(buf, "//")) {
				// v//n 
				sscanf(buf, "%d//%d", &v, &n);
				fscanf(file, "%d//%d", &v, &n);
				fscanf(file, "%d//%d", &v, &n);
				numtriangles++;
				group->numtriangles++;
				while(fscanf(file, "%d//%d", &v, &n) > 0) {
					numtriangles++;
					group->numtriangles++;
				}
			} else if (sscanf(buf, "%d/%d/%d", &v, &t, &n) == 3) {
				// v/t/n 
				fscanf(file, "%d/%d/%d", &v, &t, &n);
				fscanf(file, "%d/%d/%d", &v, &t, &n);
				numtriangles++;
				group->numtriangles++;
				while(fscanf(file, "%d/%d/%d", &v, &t, &n) > 0) {
					numtriangles++;
					group->numtriangles++;
				}
			} else if (sscanf(buf, "%d/%d", &v, &t) == 2) {
				// v/t 
				fscanf(file, "%d/%d", &v, &t);
				fscanf(file, "%d/%d", &v, &t);
				numtriangles++;
				group->numtriangles++;
				while(fscanf(file, "%d/%d", &v, &t) > 0) {
					numtriangles++;
					group->numtriangles++;
				}
			} else {
				// v 
				fscanf(file, "%d", &v);
				fscanf(file, "%d", &v);
				numtriangles++;
				group->numtriangles++;
				while(fscanf(file, "%d", &v) > 0) {
					numtriangles++;
					group->numtriangles++;
				}
			}
			break;

		default:
			// eat up rest of line 
			fgets(buf, sizeof(buf), file);
			break;
		}
	}

	// set the stats in the model structure 
	numvertices  = numvertices;
	numnormals   = numnormals;
	numtexcoords = numtexcoords;
	numtriangles = numtriangles;

	// allocate memory for the triangles in each group 
	group = groups;
	while(group) 
	{
		group->triangles = (unsigned int*)malloc(sizeof(unsigned int) * group->numtriangles);
		group->numtriangles = 0;
		group = group->next;
	}
}

// SecondPass: second pass at a Wavefront OBJ file that gets all
// the data.
// model - properly initialized OLModel structure
// file  - (fopen'd) file descriptor 
void OLModel::SecondPass(FILE* file) 
{
	OLGroup* group;            // current group pointer 
	unsigned int  material;           // current material 
	unsigned int  v, n, t;
	char        buf[128];

	// set the pointer shortcuts 
	group      = groups;

	// on the second pass through the file, read all the data into the allocated arrays 
	numvertices = numnormals = numtexcoords = 1;
	numtriangles = 0;
	material = 0;
	while(fscanf(file, "%s", buf) != EOF) 
	{
		switch(buf[0]) {
		case '#':               // comment 
			// eat up rest of line 
			fgets(buf, sizeof(buf), file);
			break;
		case 'v':               // v, vn, vt 
			switch(buf[1]) {
		case '\0':          // vertex 
			fscanf(file, "%f %f %f", 
				&vertices[3 * numvertices + 0], 
				&vertices[3 * numvertices + 1], 
				&vertices[3 * numvertices + 2]);
			numvertices++;
			break;
		case 'n':           // normal 
			fscanf(file, "%f %f %f", 
				&normals[3 * numnormals + 0],
				&normals[3 * numnormals + 1], 
				&normals[3 * numnormals + 2]);
			numnormals++;
			break;
		case 't':           // texcoord 
			fscanf(file, "%f %f", 
				&texcoords[2 * numtexcoords + 0],
				&texcoords[2 * numtexcoords + 1]);
			numtexcoords++;
			break;
			}
			break;
		case 'u':
			fgets(buf, sizeof(buf), file);
			sscanf(buf, "%s %s", buf, buf);
			group->material = material = FindMaterial(buf);
			break;
		case 'g':               // group 
			// eat up rest of line 
			fgets(buf, sizeof(buf), file);
#if SINGLE_STRING_GROUP_NAMES
			sscanf(buf, "%s", buf);
#else
			buf[strlen(buf)-1] = '\0';  // nuke '\n' 
#endif
			group = FindGroup(buf);
			group->material = material;
			break;
		case 'f':               // face 
			v = n = t = 0;
			fscanf(file, "%s", buf);
			// can be one of %d, %d//%d, %d/%d, %d/%d/%d %d//%d 
			if (strstr(buf, "//")) {
				// v//n 
				sscanf(buf, "%d//%d", &v, &n);
				triangles[numtriangles].vindices[0] = v;
				triangles[numtriangles].nindices[0] = n;
				fscanf(file, "%d//%d", &v, &n);
				triangles[numtriangles].vindices[1] = v;
				triangles[numtriangles].nindices[1] = n;
				fscanf(file, "%d//%d", &v, &n);
				triangles[numtriangles].vindices[2] = v;
				triangles[numtriangles].nindices[2] = n;
				group->triangles[group->numtriangles++] = numtriangles;
				numtriangles++;
				while(fscanf(file, "%d//%d", &v, &n) > 0) 
				{
					triangles[numtriangles].vindices[0] = triangles[numtriangles-1].vindices[0];
					triangles[numtriangles].nindices[0] = triangles[numtriangles-1].nindices[0];
					triangles[numtriangles].vindices[1] = triangles[numtriangles-1].vindices[2];
					triangles[numtriangles].nindices[1] = triangles[numtriangles-1].nindices[2];
					triangles[numtriangles].vindices[2] = v;
					triangles[numtriangles].nindices[2] = n;
					group->triangles[group->numtriangles++] = numtriangles;
					numtriangles++;
				}
			} else if (sscanf(buf, "%d/%d/%d", &v, &t, &n) == 3) {
				// v/t/n 
				triangles[numtriangles].vindices[0] = v;
				triangles[numtriangles].tindices[0] = t;
				triangles[numtriangles].nindices[0] = n;
				fscanf(file, "%d/%d/%d", &v, &t, &n);
				triangles[numtriangles].vindices[1] = v;
				triangles[numtriangles].tindices[1] = t;
				triangles[numtriangles].nindices[1] = n;
				fscanf(file, "%d/%d/%d", &v, &t, &n);
				triangles[numtriangles].vindices[2] = v;
				triangles[numtriangles].tindices[2] = t;
				triangles[numtriangles].nindices[2] = n;
				group->triangles[group->numtriangles++] = numtriangles;
				numtriangles++;
				while(fscanf(file, "%d/%d/%d", &v, &t, &n) > 0) {
					triangles[numtriangles].vindices[0] = triangles[numtriangles-1].vindices[0];
					triangles[numtriangles].tindices[0] = triangles[numtriangles-1].tindices[0];
					triangles[numtriangles].nindices[0] = triangles[numtriangles-1].nindices[0];
					triangles[numtriangles].vindices[1] = triangles[numtriangles-1].vindices[2];
					triangles[numtriangles].tindices[1] = triangles[numtriangles-1].tindices[2];
					triangles[numtriangles].nindices[1] = triangles[numtriangles-1].nindices[2];
					triangles[numtriangles].vindices[2] = v;
					triangles[numtriangles].tindices[2] = t;
					triangles[numtriangles].nindices[2] = n;
					group->triangles[group->numtriangles++] = numtriangles;
					numtriangles++;
				}
			} else if (sscanf(buf, "%d/%d", &v, &t) == 2) {
				// v/t 
				triangles[numtriangles].vindices[0] = v;
				triangles[numtriangles].tindices[0] = t;
				fscanf(file, "%d/%d", &v, &t);
				triangles[numtriangles].vindices[1] = v;
				triangles[numtriangles].tindices[1] = t;
				fscanf(file, "%d/%d", &v, &t);
				triangles[numtriangles].vindices[2] = v;
				triangles[numtriangles].tindices[2] = t;
				group->triangles[group->numtriangles++] = numtriangles;
				numtriangles++;
				while(fscanf(file, "%d/%d", &v, &t) > 0) {
					triangles[numtriangles].vindices[0] = triangles[numtriangles-1].vindices[0];
					triangles[numtriangles].tindices[0] = triangles[numtriangles-1].tindices[0];
					triangles[numtriangles].vindices[1] = triangles[numtriangles-1].vindices[2];
					triangles[numtriangles].tindices[1] = triangles[numtriangles-1].tindices[2];
					triangles[numtriangles].vindices[2] = v;
					triangles[numtriangles].tindices[2] = t;
					group->triangles[group->numtriangles++] = numtriangles;
					numtriangles++;
				}
			} else {
				// v 
				sscanf(buf, "%d", &v);
				triangles[numtriangles].vindices[0] = v;
				fscanf(file, "%d", &v);
				triangles[numtriangles].vindices[1] = v;
				fscanf(file, "%d", &v);
				triangles[numtriangles].vindices[2] = v;
				group->triangles[group->numtriangles++] = numtriangles;
				numtriangles++;
				while(fscanf(file, "%d", &v) > 0) {
					triangles[numtriangles].vindices[0] = triangles[numtriangles-1].vindices[0];
					triangles[numtriangles].vindices[1] = triangles[numtriangles-1].vindices[2];
					triangles[numtriangles].vindices[2] = v;
					group->triangles[group->numtriangles++] = numtriangles;
					numtriangles++;
				}
			}
			break;

		default:
			// eat up rest of line 
			fgets(buf, sizeof(buf), file);
			break;
		}
	}
}

OLModel::OLModel()
{
    pathname    = NULL;
    mtllibname    = NULL;
    numvertices   = 0;
    vertices    = NULL;
    numnormals    = 0;
    normals     = NULL;
    numtexcoords  = 0;
    texcoords       = NULL;
    numfacetnorms = 0;
    facetnorms    = NULL;
    numtriangles  = 0;
    triangles       = NULL;
    nummaterials  = 0;
    materials       = NULL;
    numgroups       = 0;
    groups      = NULL;
    position[0]   = 0.0;
    position[1]   = 0.0;
    position[2]   = 0.0;
}

OLModel::~OLModel()
{
    OLGroup* group;
    unsigned int i;
    
    if (pathname)     free(pathname);
    if (mtllibname) free(mtllibname);
    if (vertices)     free(vertices);
    if (normals)  free(normals);
    if (texcoords)  free(texcoords);
    if (facetnorms) free(facetnorms);
    if (triangles)  free(triangles);
    if (materials) {
        for (i = 0; i < nummaterials; i++)
            free(materials[i].name);
    }
    free(materials);
    while(groups) {
        group = groups;
        groups = groups->next;
        free(group->name);
        free(group->triangles);
        free(group);
    }
}

bool OLModel::Read(char* filename)
{
    FILE*   file;
    
    // open the file 
    file = fopen(filename, "r");
    if (!file) {
        fprintf(stderr, "Read() failed: can't open data file \"%s\".\n",
            filename);
        return false;
    }
    
    pathname = _strdup(filename);
    
    // make a first pass through the file to get a count of the number of vertices, normals, texcoords & triangles 
    FirstPass(file);
    
    // allocate memory 
    vertices = (float*)malloc(sizeof(float) * 3 * (numvertices + 1));
	triangles = (OLTriangle*)malloc(sizeof(OLTriangle) * numtriangles);
    if (numnormals) 
	{
        normals = (float*)malloc(sizeof(float) * 3 * (numnormals + 1));
    }
    if (numtexcoords) 
	{
        texcoords = (float*)malloc(sizeof(float) * 2 * (numtexcoords + 1));
    }
    
    // rewind to beginning of file and read in the data this pass 
    rewind(file);
    
    SecondPass(file);
    
    // close the file 
    fclose(file);

	return true;
}

// ReverseWinding: Reverse the polygon winding for all polygons in
// this model.   Default winding is counter-clockwise.  Also changes
// the direction of the normals.
void OLModel::ReverseWinding(void)
{
    unsigned int i, swap;
    
    for (i = 0; i < numtriangles; i++) 
	{
        swap = triangles[i].vindices[0];
        triangles[i].vindices[0] = triangles[i].vindices[2];
        triangles[i].vindices[2] = swap;
        
        if (numnormals) 
		{
            swap = triangles[i].nindices[0];
            triangles[i].nindices[0] = triangles[i].nindices[2];
            triangles[i].nindices[2] = swap;
        }
        
        if (numtexcoords) 
		{
            swap = triangles[i].tindices[0];
            triangles[i].tindices[0] = triangles[i].tindices[2];
            triangles[i].tindices[2] = swap;
        }
    }
    
    // reverse facet normals 
    for (i = 1; i <= numfacetnorms; i++) 
	{
        facetnorms[3 * i + 0] = -facetnorms[3 * i + 0];
        facetnorms[3 * i + 1] = -facetnorms[3 * i + 1];
        facetnorms[3 * i + 2] = -facetnorms[3 * i + 2];
    }
    
    // reverse vertex normals 
    for (i = 1; i <= numnormals; i++) 
	{
        normals[3 * i + 0] = -normals[3 * i + 0];
        normals[3 * i + 1] = -normals[3 * i + 1];
        normals[3 * i + 2] = -normals[3 * i + 2];
    }
}

// BuildFacetNormals: Generates facet normals for a model (by taking the
// cross product of the two vectors derived from the sides of each
// triangle).  Assumes a counter-clockwise winding.
void OLModel::BuildFacetNormals(void)
{
    unsigned int i;
    float u[3];
    float v[3];
   
    // clobber any old facetnormals 
    if (facetnorms)
        free(facetnorms);
    
    // allocate memory for the new facet normals 
    numfacetnorms=numtriangles;
    facetnorms=(float*)malloc(sizeof(float)*3*(numfacetnorms+1));
    
    for (i = 0; i < numtriangles; i++) 
	{
        triangles[i].findex = i+1;
        
        u[0] = vertices[3 * triangles[i].vindices[1] + 0] - vertices[3 * triangles[i].vindices[0] + 0];
        u[1] = vertices[3 * triangles[i].vindices[1] + 1] - vertices[3 * triangles[i].vindices[0] + 1];
        u[2] = vertices[3 * triangles[i].vindices[1] + 2] - vertices[3 * triangles[i].vindices[0] + 2];
        
        v[0] = vertices[3 * triangles[i].vindices[2] + 0] - vertices[3 * triangles[i].vindices[0] + 0];
        v[1] = vertices[3 * triangles[i].vindices[2] + 1] - vertices[3 * triangles[i].vindices[0] + 1];
        v[2] = vertices[3 * triangles[i].vindices[2] + 2] - vertices[3 * triangles[i].vindices[0] + 2];
        
        OLCross(u, v, &facetnorms[3 * (i+1)]);
        OLNormalize(&facetnorms[3 * (i+1)]);
    }
}

// BuildVertexNormals: Generates smooth vertex normals for a model.
// First builds a list of all the triangles each vertex is in.  Then
// loops through each vertex in the the list averaging all the facet
// normals of the triangles each vertex is in.  Finally, sets the
// normal index in the triangle for the vertex to the generated smooth
// normal.  If the dot product of a facet normal and the facet normal
// associated with the first triangle in the list of triangles the
// current vertex is in is greater than the cosine of the angle
// parameter to the function, that facet normal is not added into the
// average normal calculation and the corresponding vertex is given
// the facet normal.  This tends to preserve hard edges.  The angle to
// use depends on the model, but 90 degrees is usually a good start.
// angle - maximum angle (in degrees) to smooth across
void OLModel::BuildVertexNormals(float angle)
{
    OLNode*    node;
    OLNode*    tail;
    OLNode** members;
	unsigned int numnormals2;
    float average[3];
    float dot, cos_angle;
    unsigned int i, avg;
      
    // calculate the cosine of the angle (in degrees) 
    cos_angle = cosf(angle*3.14159265f/180.0f);
    
    // nuke any previous normals 
    if (normals)
        free(normals);
    
    // allocate space for new normals 
    numnormals = numtriangles * 3; // 3 normals per triangle 
    normals = (float*)malloc(sizeof(float)* 3* (numnormals+1));
    
    // allocate a structure that will hold a linked list of triangle indices for each vertex 
    members = (OLNode**)malloc(sizeof(OLNode*) * (numvertices + 1));
    for (i = 1; i <= numvertices; i++)
        members[i] = NULL;
    
    // for every triangle, create a node for each vertex in it 
    for (i = 0; i < numtriangles; i++) {
        node = (OLNode*)malloc(sizeof(OLNode));
        node->index = i;
        node->next  = members[triangles[i].vindices[0]];
        members[triangles[i].vindices[0]] = node;
        
        node = (OLNode*)malloc(sizeof(OLNode));
        node->index = i;
        node->next  = members[triangles[i].vindices[1]];
        members[triangles[i].vindices[1]] = node;
        
        node = (OLNode*)malloc(sizeof(OLNode));
        node->index = i;
        node->next  = members[triangles[i].vindices[2]];
        members[triangles[i].vindices[2]] = node;
    }
    
    // calculate the average normal for each vertex 
    numnormals2 = 1;
    for (i = 1; i <= numvertices; i++) {
    // calculate an average normal for this vertex by averaging the facet normal of every triangle this vertex is in 
        node = members[i];
        if (!node)
            fprintf(stderr, "BuildVertexNormals(): vertex w/o a triangle\n");
        average[0] = 0.0f; average[1] = 0.0f; average[2] = 0.0f;
        avg = 0;
        while (node) {
        // only average if the dot product of the angle between the two facet normals is greater than the cosine of the threshold angle -- or, said another way, the angle between the two facet normals is less than (or equal to) the threshold angle 
            dot = OLDot(&facetnorms[3 * triangles[node->index].findex],
                &facetnorms[3 * triangles[members[i]->index].findex]);
            if (dot > cos_angle) {
                node->averaged = true;
                average[0] += facetnorms[3 * triangles[node->index].findex + 0];
                average[1] += facetnorms[3 * triangles[node->index].findex + 1];
                average[2] += facetnorms[3 * triangles[node->index].findex + 2];
                avg = 1;            // we averaged at least one normal! 
            } else {
                node->averaged = false;
            }
            node = node->next;
        }
        
        if (avg) {
            // normalize the averaged normal 
            OLNormalize(average);
            
            // add the normal to the vertex normals list 
            normals[3 * numnormals2 + 0] = average[0];
            normals[3 * numnormals2 + 1] = average[1];
            normals[3 * numnormals2 + 2] = average[2];
            avg = numnormals2;
            numnormals2++;
        }
        
        // set the normal of this vertex in each triangle it is in 
        node = members[i];
        while (node) {
            if (node->averaged) {
                // if this node was averaged, use the average normal 
                if (triangles[node->index].vindices[0] == i)
                    triangles[node->index].nindices[0] = avg;
                else if (triangles[node->index].vindices[1] == i)
                    triangles[node->index].nindices[1] = avg;
                else if (triangles[node->index].vindices[2] == i)
                    triangles[node->index].nindices[2] = avg;
            } else {
                // if this node wasn't averaged, use the facet normal 
                normals[3 * numnormals2 + 0] = 
                    facetnorms[3 * triangles[node->index].findex + 0];
                normals[3 * numnormals2 + 1] = 
                    facetnorms[3 * triangles[node->index].findex + 1];
                normals[3 * numnormals2 + 2] = 
                    facetnorms[3 * triangles[node->index].findex + 2];
                if (triangles[node->index].vindices[0] == i)
                    triangles[node->index].nindices[0] = numnormals2;
                else if (triangles[node->index].vindices[1] == i)
                    triangles[node->index].nindices[1] = numnormals2;
                else if (triangles[node->index].vindices[2] == i)
                    triangles[node->index].nindices[2] = numnormals2;
                numnormals2++;
            }
            node = node->next;
        }
    }
    
    numnormals = numnormals2 - 1;
    
    // free the member information 
    for (i = 1; i <= numvertices; i++) {
        node = members[i];
        while (node) {
            tail = node;
            node = node->next;
            free(tail);
        }
    }
    free(members);
    
    // pack the normals array (we previously allocated the maximum number of normals that could possibly be created (numtriangles * 3), so get rid of some of them (usually alot unless none of the facet normals were averaged)) 
    float *normals2 = normals;
    normals = (float*)malloc(sizeof(float)* 3* (numnormals+1));
    for (i = 1; i <= numnormals; i++) {
        normals[3 * i + 0] = normals2[3 * i + 0];
        normals[3 * i + 1] = normals2[3 * i + 1];
        normals[3 * i + 2] = normals2[3 * i + 2];
    }
    free(normals2);
}

// Weld: eliminate (weld) vectors that are within an epsilon of
// each other.
// epsilon     - maximum difference between vertices
//               ( 0.00001 is a good start for a unitized model)
void OLModel::Weld(float epsilon)
{
    float* copies;
    unsigned int i;
    
    copies = OLWeldVectors(vertices, &numvertices, epsilon);
    
    for (i = 0; i < numtriangles; i++) {
        triangles[i].vindices[0] = (unsigned int)vertices[3 * triangles[i].vindices[0] + 0];
        triangles[i].vindices[1] = (unsigned int)vertices[3 * triangles[i].vindices[1] + 0];
        triangles[i].vindices[2] = (unsigned int)vertices[3 * triangles[i].vindices[2] + 0];
    }
    
    // free space for old vertices 
    free(vertices);
    
    // allocate space for the new vertices 
    vertices = (float*)malloc(sizeof(float) * 3 * (numvertices + 1));
    
    // copy the optimized vertices into the actual vertex list 
    for (i = 1; i <= numvertices; i++) {
        vertices[3 * i + 0] = copies[3 * i + 0];
        vertices[3 * i + 1] = copies[3 * i + 1];
        vertices[3 * i + 2] = copies[3 * i + 2];
    }
    
    free(copies);
}

// Draw: Renders the model to the current OpenGL context using the mode specified.
// mode  - a bitwise OR of values describing what is to be rendered.
//             GLM_NONE     -  render with only vertices
//             GLM_FLAT     -  render with facet normals
//             GLM_SMOOTH   -  render with vertex normals
//             GLM_TEXTURE  -  render with texture coords
//             GLM_COLOR    -  render with colors (color material)
//             GLM_MATERIAL -  render with materials
//             GLM_COLOR and GLM_MATERIAL should not both be specified.  
//             GLM_FLAT and GLM_SMOOTH should not both be specified.  
void OLModel::Draw(/*GLuint mode*/)
{
    unsigned int i;
    OLGroup* group;
    OLTriangle* triangle;
    //OLMaterial* material;
    
    /*// do a bit of warning 
    if (mode & GLM_FLAT && !model->facetnorms) {
        printf("glmDraw() warning: flat render mode requested "
            "with no facet normals defined.\n");
        mode &= ~GLM_FLAT;
    }
    if (mode & GLM_SMOOTH && !model->normals) {
        printf("glmDraw() warning: smooth render mode requested "
            "with no normals defined.\n");
        mode &= ~GLM_SMOOTH;
    }
    if (mode & GLM_TEXTURE && !model->texcoords) {
        printf("glmDraw() warning: texture render mode requested "
            "with no texture coordinates defined.\n");
        mode &= ~GLM_TEXTURE;
    }
    if (mode & GLM_FLAT && mode & GLM_SMOOTH) {
        printf("glmDraw() warning: flat render mode requested "
            "and smooth render mode requested (using smooth).\n");
        mode &= ~GLM_FLAT;
    }
    if (mode & GLM_COLOR && !model->materials) {
        printf("glmDraw() warning: color render mode requested "
            "with no materials defined.\n");
        mode &= ~GLM_COLOR;
    }
    if (mode & GLM_MATERIAL && !model->materials) {
        printf("glmDraw() warning: material render mode requested "
            "with no materials defined.\n");
        mode &= ~GLM_MATERIAL;
    }
    if (mode & GLM_COLOR && mode & GLM_MATERIAL) {
        printf("glmDraw() warning: color and material render mode requested "
            "using only material mode.\n");
        mode &= ~GLM_COLOR;
    }
    if (mode & GLM_COLOR)
        glEnable(GL_COLOR_MATERIAL);
    else if (mode & GLM_MATERIAL)
        glDisable(GL_COLOR_MATERIAL);
    */
    // perhaps this loop should be unrolled into material, color, flat, smooth, etc. loops?  since most cpu's have good branch prediction schemes (and these branches will always go one way), probably wouldn't gain too much?  
    
    group = groups;
    while (group) 
	{
        /*if (mode & GLM_MATERIAL) {
            material = &model->materials[group->material];
            glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, material->ambient);
            glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, material->diffuse);
            glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, material->specular);
            glMaterialf(GL_FRONT_AND_BACK, GL_SHININESS, material->shininess);
        }
        
        if (mode & GLM_COLOR) {
            glColor3fv(material->diffuse);
        }*/
        
		//glPolygonMode (GL_FRONT, GL_LINE);
		glBegin(GL_TRIANGLES);
        for (i=0;i<group->numtriangles;i++) 
		{
            triangle=&triangles[group->triangles[i]];
            
            //if (mode & GLM_FLAT)
                glNormal3fv(&facetnorms[3 * triangle->findex]);
            
            //if (mode & GLM_SMOOTH)
            //    glNormal3fv(&normals[3 * triangle->nindices[0]]);
            //if (mode & GLM_TEXTURE)
            //    glTexCoord2fv(&model->texcoords[2 * triangle->tindices[0]]);
            glVertex3fv(&vertices[3 * triangle->vindices[0]]);
            
            //if (mode & GLM_SMOOTH)
            //    glNormal3fv(&normals[3 * triangle->nindices[1]]);
            //if (mode & GLM_TEXTURE)
            //    glTexCoord2fv(&model->texcoords[2 * triangle->tindices[1]]);
            glVertex3fv(&vertices[3 * triangle->vindices[1]]);
            
            //if (mode & GLM_SMOOTH)
            //    glNormal3fv(&normals[3 * triangle->nindices[2]]);
            //if (mode & GLM_TEXTURE)
            //    glTexCoord2fv(&model->texcoords[2 * triangle->tindices[2]]);
            glVertex3fv(&vertices[3 * triangle->vindices[2]]);
            
        }
        glEnd();
        
        group=group->next;
    }
}